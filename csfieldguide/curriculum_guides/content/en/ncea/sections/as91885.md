# AS91885 (1.9)

## Demonstrate understanding of searching and sorting algorithms

The key with this standard is to be able to explain how an algorithm works (usually best done through personalised examples), and evaluate algorithms in terms of how the time they take increases as the size of the input increases.
For merit and excellence, students need to compare two contrasting algorithms for both searching and sorting.
(Students sometimes mix up algorithms for searching with those for sorting; it doesn't make sense to compare the speed of a searching algorithm with the speed of a sorting algorithm as they are achieving different things, and it's important to be aware of what the problem is that each algorithm solves.)

The material that you need to understand these ideas is in the chapter on Algorithms.
Start with the ["Big picture" introduction to the chapter]('chapters:chapter' 'algorithms'), which explains the idea of the "cost" of an algorithm (and what an algorithm is!)

The two searching algorithms that you should learn about in order to compare them are Sequential Search (sometimes referred to as Linear Search) and Binary Search, these are covered in the [searching algorithms section]('chapters:chapter_section' 'algorithms' 'searching').
These are strongly contrasting algorithms and will work well for a comparison, and they are based on a simple data structure (the array or list).
Other algorithms (yet to be added to the Field Guide) that keen students might want to explore are based on Hash Tables (these are usually faster than Binary Search and are commonly used in practice, but have more "moving parts" to understand and explain) and Search Trees (which again aren't covered in the Field Guide at this stage, but are widely used in practice).
However, Sequential Search and Binary Search provide an excellent contrasting introduction to the issues surrounding algorithms for searching, and nicely match the expectations of this standard.

Students will also need to explore one or two sorting algorithms.
There are three main sorting algorithms described within the [sorting algorithms section]('chapters:chapter_section' 'algorithms' 'sorting'): Selection Sort, Insertion Sort and Quicksort.
Selection and Insertion Sort are both slow algorithms that are easier to understand and implement, but have limited use in practice because they are unnecessarily slow for typical data; Quicksort is one of the faster methods known, and is a good contrast to the previous two.
For the achievement standard only two algorithms are needed; Selection and Quicksort provide a good contrast, otherwise Insertion and Quicksort could be used.
It would not be a good idea to compare Insertion sort with Selection sort; the differences between these are more subtle and would require more careful evaluation.
Another common sorting algorithm that is widely used in practice because it is very fast is Mergesort; this isn't currently covered in the Field Guide, but keen students could investigate it instead of Quicksort.

Once students have understood the examples of the algorithms above, it is worth going over ["What makes an algorithm"]('chapters:chapter_section' 'algorithms' 'what_makes_an_algorithm') so that they will be able to use the terminology relating to this subject accurately.

Assessment resources for this standard [can be found on the TKI website here](http://ncea.tki.org.nz/Resources-for-Internally-Assessed-Achievement-Standards/Technology/Digital-technologies/Level-1-Digital-technologies-assessment-resources).
The documents here mention the CS Field Guide where it supports that assessment.
